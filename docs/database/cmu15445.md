# CMU15445

**声明：以下内容均为个人学习使用，不做任何商业用途。文字和图片来源于[cmu15445](https://15445.courses.cs.cmu.edu/fall2022/schedule.html)**。

**Disclaimer: The following content is for personal learning use, not for any commercial use. Text and pictures are from [cmu15445](https://15445.courses.cs.cmu.edu/fall2022/schedule.html)**.

------

关系型数据库: 

- 使用简单的数据结构（关系）存储数据
- DBMS实现物理存储
- 通过高级语言获得数据，DBMS决定最佳的执行策略

------

## 数据库存储：

​	DBMS假定主要存储在磁盘上。因为磁盘是非易失的，并且成本较低且存储空间较大。

![存储结构](../img/存储结构.png)

​	由此产生的问题：磁盘上的访存速度非常慢，且随机访问的速率远小于顺序访问。

​	因此，DBMS需要解决以下问题：

- **允许DBMS管理比实际内存更大的空间**
- **减少磁盘的读写**
- **最大化顺序访问磁盘**

​	相关工作：

- mmap：[Why not mmap](https://db.cs.cmu.edu/papers/2022/cidr2022-p13-crotty.pdf)

------

​	同时，数据库往往会以多个文件的形式存储在磁盘上，一般我们通过一个页面的集合去管理这些文件。页面是固定大小的数据块，硬件页面是存储设备可以保证故障安全写入的最大数据块。由此我们会有以下问题：

- **如何确定页面的大小？**
- **对不同文件如何进行页面管理？（Heap, Tree, ISAM, Hashing）**

​	这门课中主要介绍了堆文件管理方式。堆文件是一些页面的无序集合。因此需要原数据跟踪文件中包含哪些页面以及哪些页面是空闲的。堆文件通过一个特殊的页面（页目录）跟踪数据页面的位置以及空闲的空间。

​	页面存储数据的方式：存储元组；存储日志

<center>
    ![slotted_pages](../img/slotted_pages.png)
    <br>
    <div>slotted page</div>
</center>
​	如上图所示，常见的页面存储元组的方式为slotted page。这一方式存在以下问题：

- **会有内碎片**
- **Random Disk I/O(e.g., update 20 tuples on 20 pages)**
- **Useless Disk I/O**（好像和上一条意思差不多）

​	在页面设计上同样可能面临更多的限制，比如：

- **无法over_written**
- **一个块中的页内必须从低地址往高地址顺序写**
- **块被擦除的次数有限**

​	元组：按列顺序存储数据，去规范化。可以优化的点：

- **按什么顺序存储数据？**
- **trade off: 去规范化（比如两个表有个外键关联，把两张表的元组存储在一起）。这样可能可以减少I/O的总量，但是会增加修改的成本。**

​	日志：每次对数据库进行更改时，DBMS将日志记录附加到文件的末尾，而不检查以前的日志记录。这样可以解决页面无法over_written的问题以及slotted_page对磁盘随机访问的问题，使得每一次写磁盘都是顺序的。

​	由于日志的增长是无止境的，因此我们需要定期进行日志的压缩。日志压缩需要考虑的问题有：

- **页面之间的时间顺序（这里考虑优化一下堆文件管理，让每个文件中的页面id有序，这样可以提高未来的查询效率）**
- **文件的合并需要什么条件（universal compaction：合并有相邻page id的文件。level compaction：后续补一下[Leveldb]([google/leveldb: LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values. (github.com)](https://github.com/google/leveldb))的坑）**

​	日志的缺点：

- **写需要写更多的内容**
- **日志压缩开销大**

------

​	数据：这一部分的问题包括：

- **任意精度的小数：[libfixeypointy](https://github.com/cmu-db/libfixeypointy)**
- **大数值：overflow page(额外的页面存溢出数据), [external file](https://www.microsoft.com/en-us/research/wp-content/uploads/2006/04/tr-2006-45.pdf)（专门存储大数值的文件，这个文件没有持久性和事务保护）**

------

​	数据库负载：

- OLTP：读写小量数据
- OLAP：读大量数据进行聚合计算
- HTAP：OLTP + OLAP together

​	根据不同的数据库负载类型我们可以对页面存储数据方式进行优化，比如对于OLAP我们可以采用DSM的方式，即将跨元组的单属性值连续存储在页面中（这样可以减少I/O的访存量，可以更好的进行查询和数据压缩，但同时对单点操作不利，因为一个tuple的不同属性分布在不同页上）。

------

​	数据库压缩：由于在现实世界中数据集在某个属性上的值往往具有高度偏斜性，同时同一元组之间的不同属性之间往往也具有高度的相关性。因此我们可以基于这些特点对数据库进行压缩。数据库的压缩必须保证压缩后的值是定长的（Why?），查询执行时必须尽可能推迟解压缩，必须是无损的。数据库压缩你需要考虑以下问题：

- **计算开销**
- **压缩与解压缩的速度**

​	重点介绍一下对DSM方式存储的数据进行压缩。可行的方案包括：

- run-length encoding(对数据的排序具有要求)：

<center>
    ![run-length encoding](../img/run-length_encoding.png)
    <br>
    <div>run-length encoding</div>
</center>

- bit-packing encoding

<center>
    ![bit-packing encoding](../img/bit-packing_encoding.png)
    <br>
    <div>bit-packing encoding</div>
</center>

- mostly encoding(对bit-packing的进一步优化)

<center>
    ![mostly encoding](../img/mostly_encoding.png)
    <br>
    <div>mostly encoding</div>
</center>

- bitmap encoding(低基类类别变量，类似于One-hot)

<center>
    ![bitmap encoding](../img/bitmap_encoding.png)
    <br>
    <div>bitmap encoding</div>
</center>

- delta encoding(可结合RLE，对数据平稳性有要求)

<center>
    ![delta encoding](../img/delta_encoding.png)
    <br>
    <div>delta encoding</div>
</center>

- incremental encoding(类似于上一个，但是这个是针对字符串的，所以取公共前缀作为基底)

- dictionary compression(需要注意dictionary的大小，没有magic hash function可以同时做到编码和解码，Andy认为这一方法可能是最有效的方法，因为不需要预排序)

<center>
    ![dictionary compression](../img/dictionary_compression.png)
    <br>
    <div>dictionary compression</div>
</center>

------

​	之前我们了解了数据库在磁盘上的存储，进一步我们需要解决磁盘和内存之间的来回移动问题。我们需要解决以下问题：

- **数据应该写到磁盘的哪些页上（我们应该尽可能让经常使用的页尽可能的靠近）**
- **什么时候需要把页面读入内存，什么时候需要把页面写回磁盘（我们应该尽可能减少I/O访存的次数）**

<center>
![buffer pool](../img/buffer_pool.jpg)
<br>
<div>buffer pool</div>
</center>

source from [eleven's zhihu](https://zhuanlan.zhihu.com/p/571927310)
