# CMU15445

关系型数据库: 

- 使用简单的数据结构（关系）存储数据
- DBMS实现物理存储
- 通过高级语言获得数据，DBMS决定最佳的执行策略

------

## 数据库存储：

​	DBMS假定主要存储在磁盘上。因为磁盘是非易失的，并且成本较低且存储空间较大。

![存储结构](../img/存储结构.png)

​	由此产生的问题：磁盘上的访存速度非常慢，且随机访问的速率远小于顺序访问。

​	因此，DBMS需要解决以下问题：

- **允许DBMS管理比实际内存更大的空间**
- **减少磁盘的读写**
- **最大化顺序访问磁盘**

​	相关工作：

- mmap：[Why not mmap](https://db.cs.cmu.edu/papers/2022/cidr2022-p13-crotty.pdf)

------

​	同时，数据库往往会以多个文件的形式存储在磁盘上，一般我们通过一个页面的集合去管理这些文件。页面是固定大小的数据块，硬件页面是存储设备可以保证故障安全写入的最大数据块。由此我们会有以下问题：

- **如何确定页面的大小？**
- **对不同文件如何进行页面管理？（Heap, Tree, ISAM, Hashing）**

​	这门课中主要介绍了堆文件管理方式。堆文件是一些页面的无序集合。因此需要原数据跟踪文件中包含哪些页面以及哪些页面是空闲的。堆文件通过一个特殊的页面（页目录）跟踪数据页面的位置以及空闲的空间。

​	页面存储数据的方式：存储元组；存储日志

<center>
    ![slotted_pages](../img/slotted_pages.png)
    <br>
    <div>slotted page</div>
</center>
​	如上图所示，常见的页面存储元组的方式为slotted page。这一方式存在以下问题：

- **会有内碎片**
- **Random Disk I/O(e.g., update 20 tuples on 20 pages)**
- **Useless Disk I/O**（好像和上一条意思差不多）

​	在页面设计上同样可能面临更多的限制，比如：

- **无法over_written**
- **一个块中的页内必须从低地址往高地址顺序写**
- **块被擦除的次数有限**

​	元组：按列顺序存储数据，去规范化。可以优化的点：

- **按什么顺序存储数据？**
- **trade off: 去规范化（比如两个表有个外键关联，把两张表的元组存储在一起）。这样可能可以减少I/O的总量，但是会增加修改的成本。**

​	日志：每次对数据库进行更改时，DBMS将日志记录附加到文件的末尾，而不检查以前的日志记录。这样可以解决页面无法over_written的问题以及slotted_page对磁盘随机访问的问题，使得每一次写磁盘都是顺序的。

​	由于日志的增长是无止境的，因此我们需要定期进行日志的压缩。日志压缩需要考虑的问题有：

- **页面之间的时间顺序（这里考虑优化一下堆文件管理，让每个文件中的页面id有序，这样可以提高未来的查询效率）**
- **文件的合并需要什么条件（universal compaction：合并有相邻page id的文件。level compaction：后续补一下[Leveldb]([google/leveldb: LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values. (github.com)](https://github.com/google/leveldb))的坑）**

​	日志的缺点：

- **写需要写更多的内容**
- **日志压缩开销大**

------

​	数据：这一部分的问题包括：

- 任意精度的小数：[libfixeypointy](https://github.com/cmu-db/libfixeypointy)
- 大数值：overflow page(额外的页面存溢出数据), [external file](https://www.microsoft.com/en-us/research/wp-content/uploads/2006/04/tr-2006-45.pdf)（专门存储大数值的文件，这个文件没有持久性和事务保护）

------

